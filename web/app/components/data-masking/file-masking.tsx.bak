'use client'

import { useState, useEffect } from 'react'
import { useTranslation } from '#i18n'
import { DocumentIcon, EyeIcon, PlayIcon, CheckCircleIcon } from '@heroicons/react/24/outline'
import { MaskingEngine } from '@/lib/data-masking/masking-engine'
import { SandboxManager } from '@/lib/data-masking/sandbox-manager'
import { MappingStore } from '@/lib/data-masking/mapping-store'
import type { MaskingRule } from '@/lib/data-masking/types'

interface FileMaskingProps {
  rules: MaskingRule[]
  sandboxPath: string
}

export function FileMasking({ rules, sandboxPath }: FileMaskingProps) {
  const { t } = useTranslation('dataMasking')
  const [selectedFile, setSelectedFile] = useState<File | null>(null)
  const [selectedRules, setSelectedRules] = useState<string[]>([])
  const [fileContent, setFileContent] = useState<string>('')
  const [maskedContent, setMaskedContent] = useState<string>('')
  const [showPreview, setShowPreview] = useState(false)
  const [isProcessing, setIsProcessing] = useState(false)
  const [progress, setProgress] = useState(0)
  const [status, setStatus] = useState<'idle' | 'preview' | 'processing' | 'completed' | 'error'>('idle')
  const [error, setError] = useState<string>('')

  const [sandboxManager] = useState(() => new SandboxManager())
  const [mappingStore] = useState(() => new MappingStore())
  const [maskingEngine] = useState(() => new MaskingEngine())

  useEffect(() => {
    if (sandboxPath) {
      sandboxManager.initialize().then(() => {
        sandboxManager.configureSandbox(sandboxPath).catch(console.error)
      }).catch(console.error)
    }
  }, [sandboxPath, sandboxManager])

  const handleFileSelect = async (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0]
    if (!file)
      return

    setSelectedFile(file)
    setStatus('idle')
    setError('')
    setShowPreview(false)

    try {
      const content = await file.text()
      setFileContent(content)
    }
    catch (err: any) {
      setError(`Failed to read file: ${err.message}`)
      setStatus('error')
    }
  }

  const handleRuleToggle = (ruleId: string) => {
    setSelectedRules(prev =>
      prev.includes(ruleId)
        ? prev.filter(id => id !== ruleId)
        : [...prev, ruleId],
    )
  }

  const handlePreview = async () => {
    if (!fileContent || selectedRules.length === 0) {
      setError(t('masking.errors.noRules'))
      return
    }

    setIsProcessing(true)
    setError('')
    setProgress(0)

    try {
      const activeRules = rules.filter(r => selectedRules.includes(r.id))
      const result = await maskingEngine.maskContent(fileContent, activeRules)
      setMaskedContent(result.maskedContent)
      setShowPreview(true)
      setStatus('preview')
      setProgress(100)
    }
    catch (err: any) {
      setError(`${t('masking.errors.failed')}: ${err.message}`)
      setStatus('error')
    }
    finally {
      setIsProcessing(false)
    }
  }

  const handleExecuteMasking = async () => {
    if (!selectedFile || !maskedContent) {
      setError(t('masking.errors.previewFirst'))
      return
    }

    setIsProcessing(true)
    setStatus('processing')
    setError('')
    setProgress(0)

    try {
      // Step 1: Mask content (30%)
      setProgress(30)
      const activeRules = rules.filter(r => selectedRules.includes(r.id))
      const result = await maskingEngine.maskContent(fileContent, activeRules)

      // Step 2: Save masked file to sandbox (90%)
      setProgress(90)
      const maskedFileName = `masked_${selectedFile.name}`
      await sandboxManager.saveFile(maskedFileName, result.maskedContent)

      // Complete (100%)
      setProgress(100)
      setStatus('completed')
    }
    catch (err: any) {
      setError(`${t('masking.errors.failed')}: ${err.message}`)
      setStatus('error')
    }
    finally {
      setIsProcessing(false)
    }
  }

  const handleReset = () => {
    setSelectedFile(null)
    setSelectedRules([])
    setFileContent('')
    setMaskedContent('')
    setShowPreview(false)
    setStatus('idle')
    setError('')
    setProgress(0)
  }

  return (
    <div className="space-y-6">
      {/* File Selection */}
      <div className="space-y-4">
        <div>
          <label htmlFor="file-input" className="block text-sm font-medium text-gray-700 mb-2">
            {t('masking.selectFile')}
          </label>
          <div className="flex items-center gap-4">
            <label
              htmlFor="file-input"
              className="inline-flex items-center gap-2 rounded-md border border-gray-300 bg-white px-4 py-2 text-sm font-medium text-gray-700 hover:bg-gray-50 cursor-pointer focus-within:ring-2 focus-within:ring-blue-500 focus-within:ring-offset-2"
            >
              <DocumentIcon className="h-4 w-4" />
              {t('masking.chooseFile')}
              <input
                id="file-input"
                type="file"
                onChange={handleFileSelect}
                className="sr-only"
                accept=".txt,.json,.csv,.md"
              />
            </label>
            {selectedFile && (
              <span className="text-sm text-gray-600">
                {selectedFile.name} ({(selectedFile.size / 1024).toFixed(2)} KB)
              </span>
            )}
          </div>
        </div>

        {/* Rule Selection */}
        {selectedFile && (
          <div>
            <label className="block text-sm font-medium text-gray-700 mb-2">
              {t('masking.selectRules')}
            </label>
            <div className="space-y-2 max-h-48 overflow-y-auto border border-gray-200 rounded-md p-3">
              {rules.length === 0 ? (
                <p className="text-sm text-gray-500">{t('masking.noRules')}</p>
              ) : (
                rules.map(rule => (
                  <label key={rule.id} className="flex items-center gap-2 cursor-pointer">
                    <input
                      type="checkbox"
                      checked={selectedRules.includes(rule.id)}
                      onChange={() => handleRuleToggle(rule.id)}
                      className="rounded border-gray-300 text-blue-600 focus:ring-blue-500"
                    />
                    <span className="text-sm text-gray-700">{rule.name}</span>
                    <span className="text-xs text-gray-500">({rule.strategy.type})</span>
                  </label>
                ))
              )}
            </div>
          </div>
        )}
      </div>

      {/* Action Buttons */}
      {selectedFile && selectedRules.length > 0 && (
        <div className="flex gap-3">
          <button
            type="button"
            onClick={handlePreview}
            disabled={isProcessing || status === 'completed'}
            className="inline-flex items-center gap-2 rounded-md border border-gray-300 bg-white px-4 py-2 text-sm font-medium text-gray-700 hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 disabled:opacity-50 disabled:cursor-not-allowed"
          >
            <EyeIcon className="h-4 w-4" />
            {t('masking.preview')}
          </button>
          {showPreview && (
            <button
              type="button"
              onClick={handleExecuteMasking}
              disabled={isProcessing || status === 'completed'}
              className="inline-flex items-center gap-2 rounded-md bg-blue-600 px-4 py-2 text-sm font-medium text-white hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 disabled:opacity-50 disabled:cursor-not-allowed"
            >
              <PlayIcon className="h-4 w-4" />
              {t('masking.execute')}
            </button>
          )}
          {status === 'completed' && (
            <button
              type="button"
              onClick={handleReset}
              className="inline-flex items-center gap-2 rounded-md border border-gray-300 bg-white px-4 py-2 text-sm font-medium text-gray-700 hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2"
            >
              {t('masking.maskAnother')}
            </button>
          )}
        </div>
      )}

      {/* Progress Bar */}
      {isProcessing && (
        <div className="space-y-2">
          <div className="flex justify-between text-sm text-gray-600">
            <span>{status === 'processing' ? t('masking.processing') : t('masking.generatingPreview')}</span>
            <span>{progress}%</span>
          </div>
          <div className="w-full bg-gray-200 rounded-full h-2">
            <div
              className="bg-blue-600 h-2 rounded-full transition-all duration-300"
              style={{ width: `${progress}%` }}
            />
          </div>
        </div>
      )}

      {/* Status Messages */}
      {status === 'completed' && (
        <div className="rounded-md bg-green-50 border border-green-200 p-4">
          <div className="flex items-start gap-3">
            <CheckCircleIcon className="h-5 w-5 text-green-500 mt-0.5" />
            <div>
              <p className="text-sm font-medium text-green-800">
                {t('masking.success')}
              </p>
              <p className="mt-1 text-xs text-green-700">
                {t('masking.successDescription')}
              </p>
            </div>
          </div>
        </div>
      )}

      {error && (
        <div className="rounded-md bg-red-50 border border-red-200 p-4">
          <p className="text-sm text-red-800">{error}</p>
        </div>
      )}

      {/* Preview */}
      {showPreview && maskedContent && (
        <div className="space-y-2">
          <h3 className="text-sm font-medium text-gray-700">{t('masking.previewTitle')}</h3>
          <div className="rounded-md border border-gray-300 bg-gray-50 p-4">
            <pre className="text-xs text-gray-800 whitespace-pre-wrap break-words">
              {maskedContent.substring(0, 500)}
              {maskedContent.length > 500 && '...'}
            </pre>
          </div>
        </div>
      )}
    </div>
  )
}

